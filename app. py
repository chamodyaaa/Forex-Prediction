import pandas as pd

data=pd.read_csv('eurusd_hour.csv')
print(data.head())
print(data.info())


data['Datetime'] = pd.to_datetime(data['Date'] + ' ' + data['Time'])
print(data['Datetime'].dtype)

data = data.drop(['Date', 'Time'], axis=1)

data = data.sort_values('Datetime')
data = data.reset_index(drop=True)

# print(data['Date'].dtype)
# data['Date'] = pd.to_datetime(data['Date'])
# print(data['Date'].dtype)

# data = data.sort_values(by='Date')
# data = data.reset_index(drop=True)

print(data.isnull().sum())
data = data.dropna()

print(data.duplicated().sum())

print(data.dtypes)
print(data.info())
print(data.describe())

data['Close'] = data['BC']

print(data.info())
print(data.head())

print(data['Datetime'].diff().value_counts().head())

# Create Target (Up / Down)
data['Target'] = (data['Close'].shift(-1) > data['Close']).astype(int)

# 1 → Next hour price goes UP
# 0 → Next hour price goes DOWN


# Create Moving Averages
data['MA_5'] = data['Close'].rolling(5).mean()
data['MA_10'] = data['Close'].rolling(10).mean()
data['MA_20'] = data['Close'].rolling(20).mean()

# Create Volatility
data['Volatility'] = data['Close'].rolling(10).std()

# create RSI
from ta.momentum import RSIIndicator
rsi = RSIIndicator(close=data['Close'], window=14)
data['RSI'] = rsi.rsi()

# Remove NaN from rolling calculations
data = data.dropna()

features = ['MA_5', 'MA_10', 'MA_20', 'Volatility', 'RSI']
X = data[features]
y = data['Target']

# Train-Test Split
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, shuffle=False
)

# Scale Features
from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()

X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Train Logistic Regression
from sklearn.linear_model import LogisticRegression

model = LogisticRegression()
model.fit(X_train, y_train)

# Predict
y_pred = model.predict(X_test)  

# Evaluate
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report

print("Accuracy:", accuracy_score(y_test, y_pred))
print("\nConfusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))

# Check Class Balance
print(y.value_counts(normalize=True))

# Compare With Random Forest
from sklearn.ensemble import RandomForestClassifier

rf = RandomForestClassifier(n_estimators=100)
rf.fit(X_train, y_train)

y_pred_rf = rf.predict(X_test)

print("RF Accuracy:", accuracy_score(y_test, y_pred_rf))